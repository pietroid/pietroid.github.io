<p>A simple blog with MDX.</p>
<p>I already tried in the past for a traveling blog to Egypt (check this here) a solution with Jekyll + Github actions (the recommended for doing github sites), but was a little disappointed on the way things didn't seem too easy to do.</p>
<p>Doing the traditional software development benchmarking and research (AKA googling), on "What's the best way to configure a blog with MDX?", I found multiple suggestions.</p>
<ul>
<li>Next.js with React (<a href="https://www.joshwcomeau.com/blog/how-i-built-my-blog/">example</a>)</li>
<li>Next.js with Tailwind (<a href="https://gaudion.dev/blog/nextjs-mdx-blog">example</a>)</li>
<li>Next.js github pages (<a href="https://santhalakshminarayana.github.io/blog/build-blog-with-nextjs-mdx-and-deploy-to-github-pages">example</a>)</li>
<li>Astro.js (https://astro.build/)</li>
</ul>
<p>I even found one exotic solution with rust (reference).</p>
<p>But, let's be real: it shouldn't be that complex.</p>
<h2>Getting to the basics</h2>
<p>What my solution should do is simple:</p>
<ol>
<li>Should process MDX so I don't bother myself with HTML/CSS every time I write a post</li>
<li>Should deploy simply from a push to github repository so I don't bother to use any CMS or database</li>
<li>Should be extensible and allow HTML/CSS in place if needed for demos/cool things I might wanna do in my website (for example, add a Flutter Web piece of code)</li>
</ol>
<h1>MDX</h1>
<p>MDX is an extension on Markdown files that enables to render html and JSX inside the markdown content (https://mdxjs.com/)</p>
<p>By the documentation, we can use its mdx-js lib to load any mdx and transform into a jsx document.</p>
<p>What it does is basically:</p>
<pre><code>const compiled = await compile(await fs.readFile('example.mdx'))
</code></pre>
<p>It converts to this piece of js:</p>
<pre><code>import {Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs} from 'react/jsx-runtime'

export function Thing() {
  return _jsx(_Fragment, {children: 'World'})
}

function _createMdxContent(props) {
  const _components = {h1: 'h1', ...props.components}
  return _jsxs(_components.h1, {children: ['Hello ', _jsx(Thing, {})]})
}

export default function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = props.components || {}
  return MDXLayout
    ? _jsx(MDXLayout, {...props, children: _jsx(_createMdxContent, {...props})})
    : _createMdxContent(props)
}
</code></pre>
<p>That would be used on an actual file rendered by the browser.</p>
<h2>Github MDX</h2>
<p>I am used to writing MDX in the format Github usually recognizes, so that would be nice if I could use some parser that recognizes this.</p>
<p>Luckily, this is readily mentioned on the <a href="https://mdxjs.com/guides/">MDX guides section</a> (it's so simpler to just read the  documentation, AI prompters...), and now we dive into an interesting rabbit hole.</p>
<h2>Remark</h2>
<p>Actually to render Github MDXs we need to use a <code>remark</code> , and what is <a href="https://github.com/remarkjs/remark">remark</a>?</p>
<blockquote>
<p><strong>remark</strong>Â is a tool that transforms markdown with plugins. These plugins can inspect and change your markup. You can use remark on the server, the client, CLIs, deno, etc.</p>
</blockquote>
<p>Interesting. And reading more I found a beatiful piece of code:</p>
<pre><code>import rehypeSanitize from 'rehype-sanitize'
import rehypeStringify from 'rehype-stringify'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import {unified} from 'unified'

const file = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .use(rehypeSanitize)
  .use(rehypeStringify)
  .process('# Hello, Neptune!')

console.log(String(file))
</code></pre>
<p>Seems very interesting because we can attach multiple kinds of plugins, on demand (<a href="https://github.com/remarkjs/remark/blob/main/doc/plugins.md#list-of-plugins">this is the list of the plugins</a>, a LOT). I think it can help me leverage the #3 requirement.</p>
<h1>Styling and Scaffolding</h1>
<p>We can add any style or add any other data to the documents, such some button to the home or some list of blog contents.</p>
<p>The point of using any package or library is essentially the ability to have out-of-the-box pre-configured app architecture/hierarchy. For example:</p>
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<p>In this case, we also want the most simplistic one. As I want to do almost everything from scratch or using the most flexible and simplistic solutions, I want, for the first phase:</p>
<ul>
<li>A home page</li>
<li>For each blog page:
<ul>
<li>A header</li>
<li>A footer</li>
</ul>
</li>
</ul>
<p>There are some things also cool to tackle such as:</p>
<ul>
<li>Easy to create and locate images</li>
<li>Manageable paths and URLs</li>
</ul>
<h1>Github pages</h1>
<p>One quick way to upload a site that I liked to use a lot is github pages. I like the way everything is integrated, you can use a github action and publish something on the page itself, and we don't have to worry about hosting files and configuring pipelines.</p>
<p>There should be better solutions, but this is one where I will stick because of familiarity and it gives me what I want.</p>
<h2>Custom pipeline</h2>
<p>One thing that I actually not liked was to using the default github pages recommendation, Jekyll. Although seemingly well <a href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">documented</a>, it seemed confused and I didn't have the feeling I knew what was going on.</p>
<h2>Understanding github pages</h2>
<p>Github pages is not really clear on how it does all its processes. But it basically takes a branch and can, via some action, transform into a static site that will be consumed by github pages.</p>
<p><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/using-custom-workflows-with-github-pages">Here is the doc</a> explaining what needs to be done. We just need a simple action that does things such as:</p>
<pre><code class="language-yaml">jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./
          destination: ./_site
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{steps.deployment.outputs.page_url}}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</code></pre>
<p>The build stage produces the static contents and the deploy effectively sends the content to the github pages server using the <code>actions/deploy-pages@v4</code></p>
<h1>Wrapping everything up</h1>
<ul>
<li>Creating custom repository</li>
<li>Creating simple local generator with MDX</li>
<li>Adding the scaffolding and styling</li>
<li>Configuring action</li>
<li>Uploading the first page</li>
</ul>
<h2>Creating custom repository</h2>
<p>Per the github tutorial, you must just add a custom .github.io repository that it will be able to deploy directly as your own github page.</p>
<p>I just created this repository with a index.html and it rendered the simplest site possible</p>
<p>![[Pasted image 20250314163430.png]]</p>
<h2>Creating custom local builder</h2>
<p>For now, what needs to be done for the builder is fairly simple:</p>
<ol>
<li>Read a series of posts in MDX format inside some folder</li>
<li>Compile each one of them inside a separate html page</li>
<li>Generate a home page that references all those posts</li>
</ol>
<h3>1. Reading posts inside folder</h3>
<p>Let's create a posts</p>